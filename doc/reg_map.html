<html>
  <head><title>Micromini Reg Map</title></head>
  <body>
  <h1> Micromini Reg Map </h1>
  <p><i>Generated by gen/gen_map.py</i></p>
  <p>For read registers, just write address then register then read.
  <p>For write registers, just write register.
  <p>For read/write registers, you must specify at least one  value (even if reading), though there are values that don't change the state and are only for reading back. Readbacks will always be queued for RW. 
  <hr/>
  <table border=1>
    <tr> <td> Register </td> <td> Type (R|W|RW) </td> <td> Name </td> <td> Description </td> </tr>
<tr><td>0x0</td><td>R</td><td>ID</td><td>returns 0xab</td></tr>
<tr><td>0x1</td><td>R</td><td>MAJ_VER</td><td>major version (or 0xd0 if not implemented)</td></tr>
<tr><td>0x2</td><td>R</td><td>MIN_VER</td><td>minor version (or 0xd0 if not implemented)</td></tr>
<tr><td>0x3</td><td>R</td><td>REV_VER</td><td>rev version (or 0xd0 if not implemented)</td></tr>
<tr><td>0x10</td><td>W</td><td>MEASURE</td><td>queue a new measurement</td></tr>
<tr><td>0x11</td><td>R</td><td>MEASUREMENT_AGE</td><td>age of last measurement in seconds ( saturating at 255)</td></tr>
<tr><td>0x12</td><td>R</td><td>NMEASUREMENTS</td><td>number of measurements taken (wrapping)</td></tr>
<tr><td>0x20</td><td>R</td><td>PV_LSB</td><td>LSB of PV measurement</td></tr>
<tr><td>0x21</td><td>R</td><td>PV_MSB</td><td>MSB of PV measurement</td></tr>
<tr><td>0x22</td><td>R</td><td>TURBINE_LSB</td><td>LSB of Turbine measurement</td></tr>
<tr><td>0x23</td><td>R</td><td>TURBINE_MSB</td><td>MSB of Turbine measurement</td></tr>
<tr><td>0x24</td><td>R</td><td>DELTA_PV_LSB</td><td>LSB of PV measurement</td></tr>
<tr><td>0x25</td><td>R</td><td>DELTA_PV_MSB</td><td>MSB of PV measurement</td></tr>
<tr><td>0x26</td><td>R</td><td>DELTA_TURBINE_LSB</td><td>LSB of Turbine measurement</td></tr>
<tr><td>0x27</td><td>R</td><td>DELTA_TURBINE_MSB</td><td>MSB of Turbine measurement</td></tr>
<tr><td>0x40</td><td>R</td><td>WHEN_BYTE_0</td><td>LSB byte of uptime at time of measurement</td></tr>
<tr><td>0x41</td><td>R</td><td>WHEN_BYTE_1</td><td>next to LSB byte of uptime at time of measurement</td></tr>
<tr><td>0x42</td><td>R</td><td>WHEN_BYTE_2</td><td>next to next to  LSB byte of uptime at time of measurement</td></tr>
<tr><td>0x43</td><td>R</td><td>WHEN_BYTE_3</td><td>MSB byte of uptime at time of measurement</td></tr>
<tr><td>0x50</td><td>R</td><td>T_LOCAL_MSB</td><td>MSB of local temperature sensor</td></tr>
<tr><td>0x51</td><td>R</td><td>T_LOCAL_LSB</td><td>LSB of local temperature sensor</td></tr>
<tr><td>0x52</td><td>R</td><td>T1_MSB</td><td>MSB of T1 sensor</td></tr>
<tr><td>0x53</td><td>R</td><td>T1_LSB</td><td>LSB of T1 sensor</td></tr>
<tr><td>0x54</td><td>R</td><td>T2_MSB</td><td>MSB of T2 sensor</td></tr>
<tr><td>0x55</td><td>R</td><td>T2_LSB</td><td>LSB of T2 sensor</td></tr>
<tr><td>0x5a</td><td>R</td><td>T_LOCAL_MSB_RAW</td><td>RAW_MSB of T_LOCAL sensor</td></tr>
<tr><td>0x5b</td><td>R</td><td>T1_MSB_RAW</td><td>RAW_MSB of T1 sensor</td></tr>
<tr><td>0x5c</td><td>R</td><td>T2_MSB_RAW</td><td>RAW_MSB of T2 sensor</td></tr>
<tr><td>0x60</td><td>R</td><td>AIN</td><td>Read adc value at AIN_OFFSET.</td></tr>
<tr><td>0x61</td><td>R</td><td>AIN_READY</td><td>Is AIN ready? 0 no, 1 yes</td></tr>
<tr><td>0x62</td><td>RW</td><td>AIN_OFFSET</td><td>set byte OFFSET to read</td></tr>
<tr><td>0x63</td><td>RW</td><td>AIN_NREAD</td><td>number of samples to send on AIN</td></tr>
<tr><td>0x64</td><td>RW</td><td>AIN_SOURCE</td><td>source of AIN (0-3), 0 = AIN1, 1 = AIN12, 2 = AIN13, 3= BAT_MON</td></tr>
<tr><td>0x65</td><td>RW</td><td>AIN_RATE</td><td>ain rate configuration; bits 0-2: clock prescaler, bits 3-7 SAMPLEN</td></tr>
<tr><td>0x66</td><td>RW</td><td>AIN_GAIN</td><td>ain gain configuration; bits 0-3: gain;  bits 4-7: ref</td></tr>
<tr><td>0x67</td><td>RW</td><td>AIN_NMEAS</td><td>number of samples to measure on conversion, divided by 8 minus 1 (i.e. 0 = 8, 31=256, 63 = 512, 255 = 2048)</td></tr>
<tr><td>0x70</td><td>R</td><td>AIN_HIST</td><td>Read ADC histogram value at AIN_HIST_BIN (saturates at 255, use LSB/MSB to get more</td></tr>
<tr><td>0x71</td><td>R</td><td>AIN_HIST_MSB</td><td>Read ADC histogram MSB value at AIN_HIST_BIN</td></tr>
<tr><td>0x72</td><td>R</td><td>AIN_HIST_LSB</td><td>Read ADC histogram LSB value at AIN_HIST_BIN</td></tr>
<tr><td>0x73</td><td>RW</td><td>AIN_HIST_BIN</td><td>histogram bin to read</td></tr>
<tr><td>0x74</td><td>R</td><td>AIN_HIST_MODE_BIN</td><td>mode bin of hist</td></tr>
<tr><td>0x75</td><td>R</td><td>AIN_HIST_HIGHEST_VAL</td><td>maximum populated bin of hist</td></tr>
<tr><td>0x76</td><td>R</td><td>AIN_HIST_LOWEST_VAL</td><td>maximum populated bin of hist</td></tr>
<tr><td>0x80</td><td>R</td><td>AIN_NUM_RISING_CROSSINGS</td><td>number of rising threshold crossings, recalculated on threshold change</td></tr>
<tr><td>0x81</td><td>R</td><td>AIN_NUM_FALLING_CROSSINGS</td><td>number of falling threshold crossings, recalculated on threshold change</td></tr>
<tr><td>0x82</td><td>RW</td><td>AIN_RISING_THRESH</td><td>threshold for rising threshold crossings</td></tr>
<tr><td>0x83</td><td>RW</td><td>AIN_FALLING_THRESH</td><td>threshold for falling threshold crossings</td></tr>
<tr><td>0x90</td><td>RW</td><td>WRITE_GPIOS</td><td>Write GPIOS  (bit0 = AUX_EN). First send mask, then send values. Or ask for a read for a readback.</td></tr>
<tr><td>0xa0</td><td>R</td><td>READ_GPIOS</td><td>read gpios  (bit0 = ALERT)</td></tr>
<tr><td>0xf3</td><td>R</td><td>RESET_REASON</td><td>reset reason for the MCU</td></tr>
<tr><td>0xf4</td><td>W</td><td>RESET</td><td>reset the MCU</td></tr>

    </table>
</body>
</html>